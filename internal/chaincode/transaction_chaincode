package main

import (
	"encoding/json"
	"fmt"

	"github.com/hyperledger/fabric-contract-api-go/contractapi"
)

// Estrutura para transação na blockchain
type Transaction struct {
	ID     string `json:"id"`
	Amount int    `json:"amount"`
	From   string `json:"from"`
	To     string `json:"to"`
}

// Implementação do Chaincode
type TransactionChaincode struct {
	contractapi.Contract
}

// Criar uma nova transação na blockchain
func (tc *TransactionChaincode) CreateTransaction(ctx contractapi.TransactionContextInterface, id string, amount int, from string, to string) error {
	exists, err := tc.TransactionExists(ctx, id)
	if err != nil {
		return err
	}
	if exists {
		return fmt.Errorf("transação %s já existe", id)
	}

	tx := Transaction{
		ID:     id,
		Amount: amount,
		From:   from,
		To:     to,
	}

	txJSON, err := json.Marshal(tx)
	if err != nil {
		return err
	}

	return ctx.GetStub().PutState(id, txJSON)
}

// Consultar uma transação na blockchain
func (tc *TransactionChaincode) GetTransaction(ctx contractapi.TransactionContextInterface, id string) (*Transaction, error) {
	txJSON, err := ctx.GetStub().GetState(id)
	if err != nil {
		return nil, fmt.Errorf("falha ao obter transação: %v", err)
	}
	if txJSON == nil {
		return nil, fmt.Errorf("transação %s não encontrada", id)
	}

	var tx Transaction
	err = json.Unmarshal(txJSON, &tx)
	if err != nil {
		return nil, err
	}

	return &tx, nil
}

// Verificar se a transação já existe
func (tc *TransactionChaincode) TransactionExists(ctx contractapi.TransactionContextInterface, id string) (bool, error) {
	txJSON, err := ctx.GetStub().GetState(id)
	if err != nil {
		return false, fmt.Errorf("falha ao verificar transação: %v", err)
	}

	return txJSON != nil, nil
}

// Função principal para iniciar o Chaincode
func main() {
	chaincode, err := contractapi.NewChaincode(new(TransactionChaincode))
	if err != nil {
		fmt.Printf("Erro ao criar Chaincode: %v", err)
		return
	}

	if err := chaincode.Start(); err != nil {
		fmt.Printf("Erro ao iniciar Chaincode: %v", err)
	}
}
